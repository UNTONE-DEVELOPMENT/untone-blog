{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getBgColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= max(0.5000*2., 1e-5);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getBgColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"gradient"},{"breakpoints":[],"aspectRatio":1,"userDownsample":0.25,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":[],"anchorPoint":8,"mask":0,"maskDepthLayer":1,"layerType":"image","width":3.08,"widthMode":0,"height":1,"heightMode":0,"left":0.5,"top":0.5,"src":"https://assets.unicorn.studio/images/xrVxeQv3GBRjHrZHMWPoR16ttA32/Untitled.resized.webp","imageNaturalSize":{"type":"Vec2","_x":65,"_y":65},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uSourceImage;uniform vec2 uArtboardResolution;\nuniform vec2 uMousePos;\nuniform sampler2D uBgTexture;const float TAU = 6.28318530718;\nconst float PI = 3.1415926;out vec4 fragColor;vec2 apply3DRotation(vec2 uv, vec2 elementCenter, vec2 elementSize, float rotX, float rotY, float fov, vec2 mouseRotOffset) {\nfloat angleX = rotX * TAU + mouseRotOffset.y;\nfloat angleY = rotY * TAU + mouseRotOffset.x;\nif (abs(angleX) < 0.001 && abs(angleY) < 0.001) {\nreturn uv;\n}\nvec2 pos = uv - 0.5;\nfloat aspect = elementSize.x / elementSize.y;\npos.x *= aspect;\nfloat focalLength = mix(0.5, 4.0, fov);\nfloat cosX = cos(angleX);\nfloat sinX = sin(angleX);\nfloat cosY = cos(angleY);\nfloat sinY = sin(angleY);\nvec3 rayDir = normalize(vec3(pos.x, pos.y, focalLength));\nvec3 r1;\nr1.x = rayDir.x * cosY - rayDir.z * sinY;\nr1.y = rayDir.y;\nr1.z = rayDir.x * sinY + rayDir.z * cosY;\nvec3 r2;\nr2.x = r1.x;\nr2.y = r1.y * cosX + r1.z * sinX;\nr2.z = -r1.y * sinX + r1.z * cosX;\nvec3 camPos = vec3(0.0, 0.0, -focalLength);\nvec3 c1;\nc1.x = camPos.x * cosY - camPos.z * sinY;\nc1.y = camPos.y;\nc1.z = camPos.x * sinY + camPos.z * cosY;\nvec3 c2;\nc2.x = c1.x;\nc2.y = c1.y * cosX + c1.z * sinX;\nc2.z = -c1.y * sinX + c1.z * cosX;\nif (abs(r2.z) < 0.01) {\nreturn vec2(-1.0);\n}\nfloat t = -c2.z / r2.z;\nif (t < 0.0 || t > 50.0) {\nreturn vec2(-1.0);\n}\nvec2 intersection = vec2(c2.x + t * r2.x, c2.y + t * r2.y);\nif (abs(intersection.x) > 2.0 || abs(intersection.y) > 2.0) {\nreturn vec2(-1.0);\n}\nintersection.x /= aspect;\nreturn intersection + 0.5;\n}vec4 sampleImage(vec2 canvasUV, vec2 mouseOffset, vec2 mouseRotOffset) {\nvec2 canvasPos = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);\nvec2 imageUV;float imageAspect = vec2(65, 65).x / vec2(65, 65).y;\nfloat canvasAspect = uArtboardResolution.x / uArtboardResolution.y;\nvec2 fitSize = vec2(\n(canvasAspect < imageAspect) ? uArtboardResolution.y * imageAspect : uArtboardResolution.x,\n(canvasAspect < imageAspect) ? uArtboardResolution.y : uArtboardResolution.x / imageAspect\n);\nvec2 offset = (uArtboardResolution - fitSize) * 0.5;\nvec2 adjustedPos = canvasPos + mouseOffset;\nimageUV = (adjustedPos - offset) / fitSize;\nimageUV = apply3DRotation(imageUV, vec2(0.5), vec2(65, 65), 0.0000, 0.0000, 0.5000, mouseRotOffset);\nvec2 flippedUV = vec2(imageUV.x, 1.0 - imageUV.y);\nvec4 color = textureLod(uSourceImage, flippedUV, 0.0);\nif (imageUV.x >= 0.0 && imageUV.x <= 1.0 && imageUV.y >= 0.0 && imageUV.y <= 1.0) {\nreturn color;\n} else {\nreturn vec4(0.0);\n}\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 applyImageAdjustments(vec4 color) {\nvec3 exposureColor = clamp(color.rgb + 0.0400, 0.0, 1.0);\ncolor.rgb = mix(color.rgb, exposureColor, color.a);color.rgb = clamp(color.rgb, 0.0, 1.0);\ncolor.rgb *= color.a;\nreturn color;\n}vec4 getCompositeOutput(vec2 uv, vec2 mouseOffsetPx, vec2 mouseRotOffset) {\nvec4 background = vec4(0);background = texture(uBgTexture, vTextureCoord);\nvec4 color = sampleImage(uv, mouseOffsetPx, mouseRotOffset);\ncolor = applyImageAdjustments(color);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 mouseOffsetUV = (uMousePos - 0.5) * 0.0000;\nvec2 mouseOffsetPx = mouseOffsetUV;\nvec2 mouseRotOffset = (uMousePos - 0.5) * 0.0000 * PI * 0.5;\nuv -= mouseOffsetUV;\nfragColor = getCompositeOutput(uv, mouseOffsetPx, mouseRotOffset);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1080,"_y":1080}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1}}},"id":"image"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"circle","usesPingPong":false,"trackMouse":0.26,"trackAxes":"xy","mouseMomentum":1,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}out vec4 fragColor;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat lum = luma(bg.rgb);\nfloat displacement = (lum - 0.5) * 0.5000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(max(0.5000, 0.001), max(1.0 - 0.5000, 0.001));\nfloat halfRadius = 0.6980 * 0.5;\nfloat falloffAmount = max(1.0000, 0.001);\nfloat innerEdge = halfRadius - falloffAmount * halfRadius * 0.5;\nfloat outerEdge = halfRadius + falloffAmount * halfRadius * 0.5;\nvec2 pos = vec2(0.5705521472392638, 0.6226993865030674);pos += (uMousePos - 0.5) * 0.2600;\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(-0.0162 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(-0.0162 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nfalloff = (1.0 - falloff) * 0.8700;\nvec3 circle = vec3(0.4, 0.1, 1) * falloff;vec3 blended = blend(4, vec3(0.4, 0.1, 1), bg.rgb);\ncircle = mix(bg.rgb, blended, falloff);\nvec4 color = vec4(circle, max(bg.a, falloff));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"circle"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"blur","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.3803680981595092, 0.01411042944785268) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 0 <= 1 ? 6. : 11.;\nfloat amount = (0.4520 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 0 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.3803680981595092, 0.01411042944785268) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 1 <= 1 ? 6. : 11.;\nfloat amount = (0.4520 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 1 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.3803680981595092, 0.01411042944785268) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 2 <= 1 ? 6. : 11.;\nfloat amount = (0.4520 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 2 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.3803680981595092, 0.01411042944785268) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 3 <= 1 ? 6. : 11.;\nfloat amount = (0.4520 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 3 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"vertical","value":1,"downSample":0.25},{"prop":"vertical","value":2,"downSample":0.5},{"prop":"vertical","value":3,"downSample":0.5}]},"id":"blur"},{"breakpoints":[],"aspectRatio":1.6,"userDownsample":0.25,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":[],"anchorPoint":0,"mask":0,"maskDepthLayer":1,"layerType":"shape","width":1671,"widthMode":1,"height":849,"heightMode":1,"left":0.07291666666666667,"top":0.14888888888888888,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uArtboardResolution;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(0.0, 0.0);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;return vec3(0.058823529411764705, 0.27450980392156865, 0.7803921568627451);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);halfSize = uArtboardResolution * 0.5;\np = canvasPosPx - halfSize;\nreturn sdBox(p, halfSize);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = 1671.0000;\nfloat absHeight = 849.0000;if (1 == 2) {\nabsWidth = absHeight * 1.6000;\n} else if (1 == 2) {\nabsHeight = absWidth / 1.6000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.0729, 0.1489) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 0.0000), mix(aa, 150., 0.0000), dist);\nvec2 localPos;\nlocalPos = canvasPosPx;\nvec2 localSize;\nlocalSize = uArtboardResolution;\nvec2 centerPx;\ncenterPx = uArtboardResolution * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0, 0, 0) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(5, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 1.0000);\ncolor = color + background * (1.0 - color.a);\nreturn color;\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 getCompositeOutput(vec2 uv) {\nvec4 background = vec4(0.0);background = texture(uBgTexture, vTextureCoord);vec4 color = sampleShape(uv);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * 0.0000;uv -= pos;fragColor = getCompositeOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1080,"_y":1080}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.6}}},"id":"shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"noise","usesPingPong":false,"speed":0.3,"trackMouse":0.12,"trackAxes":"xy","mouseMomentum":1,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}vec3 hash33(vec3 p3) {\np3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\np3 += dot(p3, p3.yxz + 19.19);\nreturn -1.0 + 2.0 * fract(vec3(\n(p3.x + p3.y) * p3.z,\n(p3.x + p3.z) * p3.y,\n(p3.y + p3.z) * p3.x\n));\n}float perlin_noise(vec3 p) {\nvec3 pi = floor(p);\nvec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0)));\nfloat n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0)));\nfloat n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0)));\nfloat n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0)));\nfloat n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0)));\nfloat n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0)));\nfloat n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0)));\nfloat n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x);\nfloat nx01 = mix(n001, n101, w.x);\nfloat nx10 = mix(n010, n110, w.x);\nfloat nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y);\nfloat nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz;\n}out vec4 fragColor;const float PI = 3.14159265359;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec2 getPerlinNoise(vec2 uv, vec2 textureCoord) {\nvec2 skew = vec2(0.8200, 1. - 0.8200);\nfloat noiseX = perlin_noise(vec3(\nuv * skew,\n0.0000 + uTime * 0.03\n));float noiseY = perlin_noise(vec3(\n(uv + vec2(4.37)) * skew,\n0.0000 + uTime * 0.03\n));vec2 offset = vec2(noiseX * 1.5, noiseY * 1.5) * 0.5 + 0.5;return mix(textureCoord, offset, 0.1400 * 1.2);\n}vec2 getNoiseOffset(vec2 uv, vec2 textureCoord) {\nreturn getPerlinNoise(uv, textureCoord);\n}void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.3314967615057395, 0.9718924349629123) + mix(vec2(0), (uMousePos-0.5), 0.1200);vec2 pos = mix(vec2(0.3314967615057395, 0.9718924349629123), mPos, floor(1.0000));\nvec2 drift = vec2(0, 0.0000 * uTime * 0.0125);\npos += drift * rot(0.0783 * -2. * PI);\nvec2 st = (uv - pos) * vec2(aspectRatio, 1);\nst *= 12. * 0.2500;\nst = rot(0.0783 * -2. * PI) * st;vec2 noise = getNoiseOffset(st, uv);\nfloat dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}uv = mix(uv, noise, dist);\nvec4 color = texture(uTexture, uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"noise"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"caustics","usesPingPong":false,"speed":0.06,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;vec4 permute(vec4 t) {\nreturn t * (t * 34.0 + 133.0);\n}vec3 grad(float hash) {\nvec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\nvec3 cuboct = cube;float index0 = step(0.0, 1.0 - floor(hash / 16.0));\nfloat index1 = step(0.0, floor(hash / 16.0) - 1.0);cuboct.x *= 1.0 - index0;\ncuboct.y *= 1.0 - index1;\ncuboct.z *= 1.0 - (1.0 - index0 - index1);float type = mod(floor(hash / 8.0), 2.0);\nvec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));vec3 grad = cuboct * 1.22474487139 + rhomb;grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;return grad;\n}\nvec4 bccNoiseDerivativesPart(vec3 X) {\nvec3 b = floor(X);\nvec4 i4 = vec4(X - b, 2.5);\nvec3 v1 = b + floor(dot(i4, vec4(.25)));\nvec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\nvec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\nvec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\nvec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\nhashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\nhashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);\nvec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\nvec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\nvec4 aa = a * a; vec4 aaaa = aa * aa;\nvec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\nvec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\nvec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\nvec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations)\n+ mat4x3(g1, g2, g3, g4) * aaaa;\nreturn vec4(derivative, dot(aaaa, extrapolations));\n}\nvec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) {\nmat3 orthonormalMap = mat3(\n0.788675134594813, -0.211324865405187, -0.577350269189626,\n-0.211324865405187, 0.788675134594813, -0.577350269189626,\n0.577350269189626, 0.577350269189626, 0.577350269189626);\nX = orthonormalMap * X;\nvec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);\nreturn vec4(result.xyz * orthonormalMap, result.w);\n}float ease (int easingFunc, float t) {\nreturn t;\n}vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}const float PI = 3.14159265359;vec4 normalizeNoise(vec4 noise, float amount) {\nreturn mix(noise, (noise + 0.5) * 0.5, amount);\n}mat2 rotate2d(float angle) {\nreturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}vec4 getNoise(vec3 p) {\nvec4 noise = bccNoiseDerivatives_XYBeforeZ(p);\nreturn normalizeNoise(noise, 0.2500);\n}void getCaustics(vec2 uv, out vec4 outNoise, out vec3 outColor) {\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 drift = vec2(0, 0.0000 * uTime * 0.0125);\nvec2 pos = vec2(0.5, 0.5) + drift * rotate2d(0.0000 * -2. * PI);\nfloat mDist = ease(0, max(0.,1. - distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if(0 == 1) {\nmDist = max(0., (0.5 - mDist));\n}uv -= pos;\nuv = uv * aspect * rotate2d(0.0000 * 2. * PI) * vec2(1. - 0.0000, 1.) * 16.0 * 0.1800;float refraction = mix(0.25, 1.3, 0.5000);vec3 p = vec3(uv, uTime * 0.05);\nvec4 noise = getNoise(p);\nvec4 baseNoise = noise;\nvec4 balanceNoise = getNoise(p - vec3(baseNoise.xyz / 32.0) * refraction);\nnoise = getNoise(p - vec3(balanceNoise.xyz / 16.0) * refraction);float balancer = (0.5 + 0.5 * balanceNoise.w);\nfloat normalized = pow(0.5 + 0.5 * noise.w, 2.);\nfloat value = mix(0., normalized + 0.2 * (1.0 - normalized), balancer * mDist);\noutNoise = baseNoise * mDist;\noutColor = vec3(0.6, 0.7, 0.9) * value;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 causticNoise;\nvec3 causticColor;\ngetCaustics(uv, causticNoise, causticColor);\nvec4 color = texture(uTexture, uv + causticNoise.xy * 0.01 * 0.2500);\nvec3 blended = blend(1, color.rgb, causticColor);\ncolor.rgb = mix(color.rgb, blended, 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"caustics"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.5,"layerType":"effect","type":"mouseDraw","usesPingPong":true,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform sampler2D uPingPongTexture;uniform sampler2D uMaskTexture;\nuniform int uIsMask;\nuniform vec2 uMousePos;\nuniform float uParentTrackMouse;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((src.x <= 0.5) ? (dst.x - (1.0 - 2.0 * src.x) * dst.x * (1.0 - dst.x)) : (((src.x > 0.5) && (dst.x <= 0.25)) ? (dst.x + (2.0 * src.x - 1.0) * (4.0 * dst.x * (4.0 * dst.x + 1.0) * (dst.x - 1.0) + 7.0 * dst.x)) : (dst.x + (2.0 * src.x - 1.0) * (sqrt(dst.x) - dst.x))), (src.y <= 0.5) ? (dst.y - (1.0 - 2.0 * src.y) * dst.y * (1.0 - dst.y)) : (((src.y > 0.5) && (dst.y <= 0.25)) ? (dst.y + (2.0 * src.y - 1.0) * (4.0 * dst.y * (4.0 * dst.y + 1.0) * (dst.y - 1.0) + 7.0 * dst.y)) : (dst.y + (2.0 * src.y - 1.0) * (sqrt(dst.y) - dst.y))), (src.z <= 0.5) ? (dst.z - (1.0 - 2.0 * src.z) * dst.z * (1.0 - dst.z)) : (((src.z > 0.5) && (dst.z <= 0.25)) ? (dst.z + (2.0 * src.z - 1.0) * (4.0 * dst.z * (4.0 * dst.z + 1.0) * (dst.z - 1.0) + 7.0 * dst.z)) : (dst.z + (2.0 * src.z - 1.0) * (sqrt(dst.z) - dst.z))));\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.1415926;out vec4 fragColor;vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pingpongUv = uv;vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb;\nvec3 mouseTrail = rgb2hsv(mouseRgb);\nfloat angle = mouseTrail.x;\nfloat strength = mouseTrail.z * (1.0000 * 5.0);vec2 direction = angleToDir(angle);vec4 bg = texture(uTexture, uv - (direction * 0.1 * strength * 0.0000));\nvec4 color = vec4(0,0,0,1);color.rgb = vec3(strength * mix(mouseRgb, vec3(0.12941176470588237, 0, 1), 0.5800));\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\nvec3 blendedRgb = blend(12, color.rgb + dither, bg.rgb);\ncolor = vec4(mix(bg.rgb, blendedRgb, mouseTrail.z), 1.0);\nif(uIsMask == 1) {\nvec2 maskPos = mix(vec2(0), (uMousePos - 0.5), uParentTrackMouse);\nvec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos);\ncolor = color * (maskColor.a * maskColor.a);\n}\nfragColor = color;}","#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uPingPongTexture;\nuniform vec2 uPreviousMousePos;uniform vec2 uMousePos;\nuniform vec2 uResolution;const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;out vec4 fragColor;vec3 toLinear(vec3 c) { return c * c; }\nvec3 toGamma(vec3 c) { return sqrt(c); }vec3 hsv2rgb(vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}vec3 rgb2hsv(vec3 c) {\nvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\nvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);\nfloat e = 1.0e-10;\nreturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}vec2 angleToDir(float angle) {\nfloat rad = angle * 2.0 * PI;\nreturn vec2(cos(rad), sin(rad));\n}float trailIntensity(vec2 segStart, vec2 correctedUv, vec2 scaledDir, float segLen, float aspectRatio, float radius, float bloomExp) {\nvec2 posToUv = (correctedUv - segStart) * vec2(aspectRatio, 1.0);\nfloat projection = clamp(dot(posToUv, scaledDir), 0.0, segLen);\nvec2 closestPoint = segStart * vec2(aspectRatio, 1.0) + scaledDir * projection;float distToLine = distance(correctedUv, closestPoint);\nfloat s = (1.0 + radius) / (distToLine + radius) * radius;return pow(s, bloomExp);\n}void main() {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 uv = vTextureCoord;\nvec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec3 lastFrameColor = texture(uPingPongTexture, uv).rgb;vec3 hsv = rgb2hsv(lastFrameColor);\nfloat prevStrength = rgb2hsv(toLinear(lastFrameColor)).z;\nvec2 prevDir = angleToDir(hsv.x);\nvec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0);\nfloat dist = length(dir);float blurAmount = 0.03 * prevStrength;\nuv = uv - prevDir * blurAmount;lastFrameColor = toLinear(texture(uPingPongTexture, uv).rgb);vec2 mouseVec = uMousePos - uPreviousMousePos;\nfloat mouseLen = length(mouseVec);\nvec2 normDir = mouseLen > 0.0 ? mouseVec / mouseLen : vec2(0.0);\nvec2 scaledDir = normDir * vec2(aspectRatio, 1.0);float angle = atan(dir.y, dir.x);\nif (angle < 0.0) angle += TAU;\nvec3 pointColor = toLinear(hsv2rgb(vec3(angle / TAU, 1.0, 1.0)));\nfloat bloomExp = 10.0 * (1.0 - 0.6000 + 0.1);int numPoints = int(max(6.0, dist * 24.0));\nfloat speedFactor = clamp(dist, 0.7, 1.3);\nfloat radius = mix(0.1, 0.7, 0.8200 * speedFactor);float segLenAspect = mouseLen * aspectRatio / float(numPoints);\nfloat totalIntensity = 0.0;\nint iter = min(numPoints, 16);totalIntensity += trailIntensity(uPreviousMousePos, correctedUv, scaledDir, 0.0, aspectRatio, radius, bloomExp);for (int i = 1; i <= iter; i++) {\nfloat t = float(i - 1) / float(numPoints);\nvec2 segStart = mix(uPreviousMousePos, uMousePos, t);\ntotalIntensity += trailIntensity(segStart, correctedUv, scaledDir, segLenAspect, aspectRatio, radius, bloomExp);\n}vec3 trailColor = pointColor * totalIntensity / float(min(numPoints, 50) + 1);float clampedDist = clamp(length(trailColor) * dist, 0.0, 1.0);\nfloat blurRadius = 0.005;vec3 blurredLastFrame = lastFrameColor * 0.2;\nblurredLastFrame += toLinear(texture(uPingPongTexture, uv + vec2(blurRadius, 0.0)).rgb) * 0.2;\nblurredLastFrame += toLinear(texture(uPingPongTexture, uv + vec2(-blurRadius, 0.0)).rgb) * 0.2;\nblurredLastFrame += toLinear(texture(uPingPongTexture, uv + vec2(0.0, blurRadius)).rgb) * 0.2;\nblurredLastFrame += toLinear(texture(uPingPongTexture, uv + vec2(0.0, -blurRadius)).rgb) * 0.2;blurredLastFrame *= pow(1.0000, 0.2);\nvec3 draw = mix(blurredLastFrame, trailColor, clampedDist);draw = toGamma(draw);\ndraw = max(draw - 0.01, vec3(0.0));fragColor = vec4(draw, 1.0);\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}","#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"light_trail"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.5,"layerType":"effect","type":"sdf_shape","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/images/xrVxeQv3GBRjHrZHMWPoR16ttA32/Vector_v1_combined_1767584438279.png","sampler":"uCustomTexture"},"speed":0.54,"trackMouseMove":0,"trackAxes":"xy","mouseMomentum":0,"trackMouse":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uCustomTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.141592653;\nconst float PI2 = 6.283185306;\nconst int DISP_STEPS = 12;\nconst vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize;\nfloat customTexAspect;const mat3 ROT_Y_90 = mat3(\n0.0, 0.0, 1.0,\n0.0, 1.0, 0.0,\n-1.0, 0.0, 0.0\n);const mat3 ROT_Z_90 = mat3(\n0.0, -1.0, 0.0,\n1.0, 0.0, 0.0,\n0.0, 0.0, 1.0\n);const mat3 ROT_X_90 = mat3(\n1.0, 0.0, 0.0,\n0.0, 0.0, -1.0,\n0.0, 1.0, 0.0\n);mat3 rotY(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}mat3 rotX(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}mat3 rotZ(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}vec3 twistY(vec3 p, float amount) {\nfloat c = cos(amount * p.y);\nfloat s = sin(amount * p.y);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(m * p.xz, p.y);\n}vec3 twistX(vec3 p, float amount) {\nfloat c = cos(amount * p.x);\nfloat s = sin(amount * p.x);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(p.x, m * p.yz);\n}float opExtrusion(vec3 p, float d, float h) {\nvec2 w = vec2( d, abs(p.z) - h );\nreturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}float sdStar5(vec2 p, float r, float rf)\n{\nconst vec2 k1 = vec2(0.809016994375, -0.587785252292);\nconst vec2 k2 = vec2(-k1.x,k1.y);\np.x = abs(p.x);\np -= 2.0*max(dot(k1,p),0.0)*k1;\np -= 2.0*max(dot(k2,p),0.0)*k2;\np.x = abs(p.x);\np.y -= r;\nvec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\nfloat h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\nreturn length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}float median(float r, float g, float b) {\nreturn max(min(r, g), min(max(r, g), b));\n}float sdCustom(vec3 p) {\np *= rotX(radians(90.0));\np *= rotY(radians(180.0));\np *= rotZ(radians(180.0));\nvec2 uv = p.xy * 0.25 + 0.5;\nif (customTexAspect > 1.0) {\nuv.y = (uv.y - 0.5) * customTexAspect + 0.5;\n} else {\nuv.x = (uv.x - 0.5) / customTexAspect + 0.5;\n}vec4 sdColor = texture(uCustomTexture, uv);\nfloat msdf = median(sdColor.r, sdColor.g, sdColor.b);\nfloat sdf = sdColor.a;\nfloat sd = msdf;\nif(sdf < 1.) {\nfloat tuning = 0.023;\nsd = mix(msdf, max(msdf - tuning, sdf), sdf);\n}float screenPxDistance = sd - 0.5;\nfloat d = -screenPxDistance;return opExtrusion(p, d, 0.1400 * 0.5);\n}vec3 getRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getThreeDRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getAdjustedP(vec3 p) {\nfloat scale = max(0.4200, 0.000000001);\nfloat scaleFactor = 1.0/scale;\nvec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.0000 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000);\nvec2 axis = vec2(-1. * vec3(0, 0, 0).y - 1. + mousePos.y/PI, vec3(0, 0, 0).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02;\nfloat timeX = vec3(0, 1, 0).x * baseTime;\nfloat timeY = vec3(0, 1, 0).y * baseTime;\nfloat timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI);\nmat3 rotXMat = rotX(axis.x * PI);\nmat3 rotZMat = rotZ(vec3(0, 0, 0).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat;\nmat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP;\nadjustedP = combinedAnimation * adjustedP;\nadjustedP = getThreeDRepeat(adjustedP);\nadjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y)));\nadjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP;\n}float getMergedSDF(vec3 p) {\np = getAdjustedP(p);\nreturn sdCustom(p);\n}float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {\nfloat NdotV = abs(dot(eyeVector, worldNormal));\nfloat width = fwidth(dot(eyeVector, worldNormal));\nfloat threshold = 0.2;\nfloat edgeDampFactor = smoothstep(threshold, -threshold, width);\nfloat fresnelFactor = 1.0 - NdotV;\nreturn pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5);\n}vec3 noFrostOrDispersion(vec3 rd, vec3 normal) {\nfloat ior = 1.0 / (1.0 + 0.1700 * 0.25);\nvec3 refractedRay = refract(rd, normal, ior);\nreturn texture(uTexture, vTextureCoord - refractedRay.xy).rgb;\n}vec3 frostOrDispersion(vec3 rd, vec3 normal) {\nvec3 refractionColor = vec3(0);\nfloat iorBase = 1. + 0.1700 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.6300 * 1.2;for (int i = 0; i < DISP_STEPS; ++i) {\nfloat step = float(i) / float(DISP_STEPS);\nvec3 disp = step * dispCoefficients;\nvec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r);\nvec3 refractedRayG = refract(rd, normal, ior.g);\nvec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r;\nrefractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g;\nrefractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b;\n}return clamp(refractionColor / float(DISP_STEPS), 0.0, 1.0);\n}vec3 calculateNormal(vec3 p, float eps) {\nvec2 e = vec2(1.0, -1.0) * eps * 0.5;\nreturn normalize(\ne.xyy * getMergedSDF(p + e.xyy) +\ne.yyx * getMergedSDF(p + e.yyx) +\ne.yxy * getMergedSDF(p + e.yxy) +\ne.xxx * getMergedSDF(p + e.xxx)\n);\n}vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal);\nreturn noFrostOrDispersion(rd, normal);\n}float scene(vec3 p) {\nreturn max(0.0000000001, getMergedSDF(p) - (0.0000 + 0.005)) * max(0.4200, 0.000000001);\n}const int STEPS = 128;\nconst float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) {\nfloat pixelSize = 0.0025;\nfloat traveled = 0.;\nvec3 entryPoint = vec3(0.0);\nvec3 entryNormal = vec3(0.0);\nfloat partialAlpha = 0.0;\nfloat lastDistance = 0.0;\nfloat smoothing = mix(1., 4., 0.0000);for (int i = 0; i < STEPS; ++i) {\nvec3 currentPos = ro + rd * traveled;\nfloat distance = scene(currentPos);\nfloat progress = float(i)/float(STEPS);\nfloat step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) {\npartialAlpha = 1.;\nentryPoint = currentPos;\nentryNormal = calculateNormal(entryPoint, pixelSize * smoothing);\nbreak;\n}lastDistance = distance;traveled += max(step, pixelSize);\nif (traveled > MAX_DISTANCE) break;\n}if (partialAlpha == 0.0) {\nreturn vec4(0);\n}vec3 samplePosition = mix(rd, entryPoint, 0.0000);vec3 refractionColor = texture(uTexture, vTextureCoord).rgb;refractionColor = sampleTexture(samplePosition, entryNormal);\nvec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.5), vec3(0.25, 0.25, -3).z);\nvec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir);\nvec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.0000);\nvec3 fresnelEffect = vec3(0.0);fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.5000 * vec3(1, 1, 1);vec3 specularEffect = vec3(0.0);vec3 halfwayDir = normalize(lightDir + rd);\nfloat specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.5000 + 0.01);\nspecularEffect = specFactor * 0.5000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect;\nvec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.0000);\nfinalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor;\n}out vec4 fragColor;void main() {\nvec4 col = vec4(0);\nvec4 bg = texture(uTexture, vTextureCoord);customTexSize = textureSize(uCustomTexture, 0);\ncustomTexAspect = float(customTexSize.x) / float(customTexSize.y);if(float(customTexSize.x) == float(uResolution.x) && float(customTexSize.y) == float(uResolution.y)) {\ndiscard;\n}if(0.4200 <= 0.0001 || 1.0000 <= 0.0001) {\ncol = vec4(0);\nif(0 == 1) {\ncol = bg;\n}\nfragColor = col;\nreturn;\n}vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 uv = vTextureCoord - pos;\nfloat fovFactor = tan(radians(20.) * 0.5);\nvec3 rd = vec3(uv * fovFactor, 0.5);\ncol = rayMarch(viewDir, rd);\nfloat dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0;\ncol += dither;col = mix(vec4(0), col, 1.0000);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"3d_shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.5,"layerType":"effect","type":"coloration","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;vec3 getFilteredColor(vec3 color) {\nreturn color;\n}float hueToRgb(float p, float q, float t) {\nif (t < 0.0) t += 1.0;\nif (t > 1.0) t -= 1.0;\nif (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t;\nif (t < 1.0 / 2.0) return q;\nif (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0;\nreturn p;\n}vec3 hslToRgb(vec3 hsl) {\nfloat h = hsl.x;\nfloat s = hsl.y;\nfloat l = hsl.z;\nvec3 rgb = vec3(l);\nif (s != 0.0) {\nfloat q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\nfloat p = 2.0 * l - q;\nrgb.r = hueToRgb(p, q, h + 1.0 / 3.0);\nrgb.g = hueToRgb(p, q, h);\nrgb.b = hueToRgb(p, q, h - 1.0 / 3.0);\n}\nreturn rgb;\n}vec3 rgbToHsl(vec3 rgb) {\nfloat max = max(max(rgb.r, rgb.g), rgb.b);\nfloat min = min(min(rgb.r, rgb.g), rgb.b);\nfloat h, s, l = (max + min) / 2.0;if (max == min) {\nh = s = 0.0;\n} else {\nfloat d = max - min;\ns = l > 0.5 ? d / (2.0 - max - min) : d / (max + min);\nif (max == rgb.r) {\nh = (rgb.g - rgb.b) / d + (rgb.g < rgb.b ? 6.0 : 0.0);\n} else if (max == rgb.g) {\nh = (rgb.b - rgb.r) / d + 2.0;\n} else if (max == rgb.b) {\nh = (rgb.r - rgb.g) / d + 4.0;\n}\nh /= 6.0;\n}return vec3(h, s, l);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);if(color.a <= 0.001) {\nfragColor = vec4(0);\nreturn;\n}color.rgb = rgbToHsl(color.rgb);\ncolor.x = fract(color.x + 1.0000);\ncolor.y = clamp(color.y * 1.1700, 0.0, 1.0);\ncolor.z = clamp(color.z + -0.0500, 0.0, 1.0);\ncolor.rgb = hslToRgb(color.rgb);\ncolor.rgb = getFilteredColor(color.rgb);color.rgb = 1.1500 * (color.rgb - 0.5) + 0.5;color.r = clamp(color.r + -0.0200, 0.0, 1.0);\ncolor.b = clamp(color.b - -0.0200, 0.0, 1.0);color.g = clamp(color.g - 0.0000, 0.0, 1.0);\ncolor.r = clamp(color.r + 0.0000 * 0.5, 0.0, 1.0);\ncolor.b = clamp(color.b + 0.0000 * 0.5, 0.0, 1.0);color = vec4(clamp(color.rgb, 0.0, 1.0), color.a);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"adjust"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/media/glyphs/runes.png","sampler":"uSprite"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 2.0 * src + dst - 1.0;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.8800);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 0.5800), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(0 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(0 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.0000 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uSprite, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 1.0000);\nvec3 blended = blend(15, dithered, bg.rgb);\ncolor.rgb = mix(bg.rgb, blended, 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"glyph_dither"}],"options":{"name":"NETRO_GLYPH","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.5","id":"3hjWHjSm44I5MOPjzbEY"}